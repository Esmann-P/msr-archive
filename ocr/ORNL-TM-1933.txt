 

~ aN iY dy,

MASTER
OAK RIDGE NATIONAL  SOBR% ey

operated by

UNION CARBIDE CORPORATION
NUCLEAR DIVISION ig
for the

 

U.S. ATOMIC ENERGY COMMISSION 0
ORNL- TM- 1933 |

COPY No-£ 33

DATE - August 30, 1967

"MATEXP, " A GENERAL PURPOSE DIGITAL COMPUTER PROGRAM FOR
SOLVING ORDINARY DIFFERENTIAL EQUATIONS
BY THE MATRIX EXPONENTIAL METHOD

S. J. Ball R. K. Adams

ABSTRACT

MATEXP, a general purpose digital computer program, was
written for solving systems of ordinary differential equations
by the matrix exponential method. MATEXP has several advantages
over standard numerical integration routines. It gives virtually
exact solutions to constant-coefficient homogeneous equations
and to nonhomogeneous equations for which the forcing functions
are constant during the computation interval. The speed at which
the equations are solved and the accuracy of the solution are
essentially unaffected either by the degree of cross-coupling
of the equations or by whether or not the coefficient matrix is
nonsingular or that its eigenvalues are distinct.

The method has been extended to nonlinear equations and
equations with time-varying coefficients; this use is very
effective for engineering systems analysis problems.

NOTICE This document contains information of a preliminary nature
and was prepared primarily for internal use at the Oak Ridge National
Laboratory. It is subject to revision or correction and therefore does
not represent a final report.

 
 

 

LEGAL NOTICE

 

This report was prepared as an account of Government sponsored work. Neither the United States,

nor the Commission, nor any person acting on behalf of the Commission:

A. Makes any warranty or representation, expressed or implied, with respect to the accuracy,
completeness, or usefulness of the information contained in this report, or that the use of

any information, apperatus, method, or process disclosed in this report may not infringe

 

privately owned rights; or
B. Assumes any liabilities with respect to the use of, or for damages resulting from the use of
any information, apparatus, method, or process disclosed in this report.

As used in the above, “person acting on behalf of the Commission” includes any employes or
contractor of the Commission, or employee of such contractor, to the extent that such employee
or contractor of the Commission, or employes of such contractor prepares, disseminates, or
provides access to, any information pursuant to his employment or contract with the Commission,
or his employment with such contractor.

 

 

 

 
‘CONTENTS

IntroductiOnecececesssveecsssencesssaccnsnossaces

Development of the Matrix Exponential Method

2.1 For Homogeneous EquationsSeeeecececescccceeses

. 2.2 For Nonhomogeneous EquationsS.ceeceeecescscees

2.3 Miscellaneous Features of the Matrix

EXDONEN A081 ss eas aessosossesaanssssnsnnns

Description of MATEXP Program and Options
3.1 Basic Input INFOrmation. essescessseennness
3.2 Alternative Methods of Generating the
Coefficient MatriX Aciecececccsssccnsccans
3.3 Alternative Methods of Generating the
© Forcing Function VECtOr Zueeeeeesessseees
3.4 Methods for Solving Time-Varying-Parameter
and Nonlinear Differential Equations.....

3.5 Special Forcing Function Subroutines.ssces.

Summary and CONCLUSIONS ee sessrassssssceansesnsane

Appendix

5.1 Problems in the Evaluation of Exponential
FUNCEAONS « «ss es sennnnssesesesnssninnnnnes

5.2 Detailed Description of Programs.ececececceces

5.3 Fortran Listing of ProgramsS.seceesccecscescss

Page

Oo ON O

11
13
13
15
16
19
oo

27
28

28

30
.
1. INTRODUCTION

The matrix exponential method of solving differential equations
was first described to the authors by Prof: Henry Paynter of MIT,
who with his students 3 developed this method into a practical
engineering tool. The basic technique was derived many years ago,
and even then it was an elegant method of obtaining exact solutions
for a set of constant coefficient, homogeneous differential equations.
The matrix exponential technique is ideally suited to digital
computation and is very simple to implement, especially when compared
with most quadrature methods.

Only two persons besides Prof. Paynter have done extensive work

>

in this area. L. Pease” of Atomic Energy of Canada, Ltd., in-

dependently developed the method simultaneously with Paynter. The
work of Paynter and Pease formed the basis for our implementation

and, perhaps, refinement of the method, although the work of several

5-9

researchers established the rigor of the central technique.

17. Suez, Automated Programming for Analog Computers, M.S.
thesis, MIT, Aug. 1962.
24 0.0. Lee, Some Finite Difference Models for Linear and
Nonlinear Control Studies Using Digital Computation, M.S. thesis,
MIT, Aug. 1962.

“3q. M. Paynter and J. Suez, "Automatic Digital Setup and Scaling
of Analog Computers," Trans. ISA, 3, 55-64 (Jan. 1964).

by, Artin, from O. Schreier and E. Sperner, Introduction to
Modern Algebra and Matrix Theory (1935); Translated from German,
Chelsea Publ. Co., N.Y., 1951, pp. 319-320.

1, Pease, DEEMS, A Fortran Program for Solving the First-Degree
Coupled Differential Equations by Expansion in Matrix Series,
AECL-1898 (Oct. 1963, reprinted Feb. 196k).

%s. G. Keller, Mathematics of Modern Engineering, vol.II,
Mathematical Engineering, Wiley, N.Y., 1942, pp. 234-246.

TR. Bellman, Introduction to Matrix Analysis, McGraw-Hill, N.Y.,
1960, pp. 165-173.

Ta
More recently, M. L. Liou of Bell Telephone Laboratories made important
contributions to the matrix exponent ial method . 10” 11

Because this method can give virtually exact? solutions to systems
of equations, it is of ‘considerable interest to most engineers engaged
in systems analysis, automatic control, and simulation. Also, systems
engineers have long recognized that one essential difference between
the analog computer and the digital computer is the awkward (at best)
manner in which the digital machine can perform integration. The
matrix exponential method, on the other hand, requires the digital
computer to perform mainly matrix manipulations, which it can do in
a very straightforward and efficient manner.

The matrix exponential techniques have worked well for a large
general class of simulation problems which constitute the bulk of the
work in the systems analysis and automatic control fields. Indeed,
by use of the methods described in Sect. 3.4, certain types of non-
linear equations can be solved as a natural extension of the basic

matrix exponential method.

8g, R. Gantmakher, Applications of the Theory of Matrices,
Interscience, N.Y., 1959, pp. 135-9. (translation of Russian

original book: Theory of Matrices, 1954).

 

IL. A. Pipes, Applied Mathematics for Engineérs and Physicists,
2d ed., McGraw-Hill, N.Y., 1958, pp. 101-k.

Oy. 1. Liou, "A Novel Method of Evaluating Transient ‘Responses, "

Proc. IEEE, oh (1), 20-23 (Jan. 1966).

 

lip, F. Kuo and J. F. Kaiser, eds., System Analysis by Digital
Computer, Wiley, N.Y.,1966, PP. 99-129.

 

120i rtually exact" means that the solution can be calculated
to as great a precision as is desired, consistent with the precision
obtainable with a given computer word length. In other words, the
precision of the method is not necessarily limited by the convergence
of any approximate quadrature (integration) formula, simply because’
quadrature is. not performed.
The matrix exponential method has also been implemented and used
extensively in Fourier analysis problems by simulating band-pass
filters. 3 14 Instead of calculating correlation functions (and
subsequently their Fourier transforms) digital filtering can be used
to obtain spectral density estimates and transfer functions from
noise data. Calculations using filtering techniques are of comparable
accuracy and typically more efficient than the conventional methods.
MATEXP has also been used in a special technique to calculate the
sensitivities of the time response of a system to changes in parameter
values. = A description of a subroutine which was written to
implement time response sensitivity calculations is given in Sect.
5.2.3.

MATEXP has been developed and modified over a period of several
~ years, and its present form reflects the considerable number of
helpful suggestions we have had from many people. We are particularly
grateful to Prof. H. M. Paynter for first introducing us to the
method, and to Prof. T. W. Kerlin of the University of Tennessee, '

and J. V. Wilson of ORNL for their help and encouragement.
2. DEVELOPMENT OF THE MATRIX EXPONENTIAL METHOD

2.1 For Homogeneous Equations
Consider the first-order scalar, linear, homogeneous differential
equation (with constant coefficient)

dx
3 Tax=0, Co . (1)

13s. J. Ball, A Digital Filtering Technique for Efficient Fourier
Transform Calculations, ORNL-TM-1778 (July 1967).
| W. Kerlin and S. J. Ball, Experimental Dynamic Analysis of
the Molten-Salt Reactor Experiment, ORNL-TM-1647 (Oct. 1966).

 

 

 

Yr. wu. Kerlin, "Sensitivities by the State Variable Method,"
Simulation, 8(6), 337-345 (June 1967). .
whose solution is Co
x =e x, (2)
0
An interesting characteristic of the solution is that, for any
time interval tT, the value of x at the end of the interval is a i
product of an exponential term 27 and the value of x at the beginning

of the interval, i.e.

x = € X, (3)

This will be referred to as the "incremental solution.”
Now because a system of homogeneous linear equations of any
order can always be broken up into a set of first-order equations,

consider the following set of equations

ax,

-_r = a

+ a X, + eoee &
at x

1 12 72 in *n ’

ax

2
TO = 8p Xp tf 8p Xp tf oeees By Xo, (4)

dx
n

dt

|] eee |

a, eeoes 8 X .
) n

+ +
nl *1 Sno Xo nn
This array can be expressed compactly in matrix form as a first-
order, linear, homogeneous, matrix differential equation with constant
coefficients, i.e.
ax :
at = AX J (5)

where X is the column vector of state variables x;

0

a cesses Re
and A represents the coefficient matrix

17 890 sees se gn

a, 8,
21 22 ee oo 00 8h

an ano sesso an

This matrix equation has the solution

For a formal proof that Eq. (6) is the desired solution, the reader

is referred to Bellman. However, the following sigple proof is

somewhat less formal. First, if dX/dt = AX, then 1% = a &X _

: 22 at
ax a™x

AAX= 22%; similarly, he a3 X, so that ===82x. (7
dt dt

If X, is expanded about zero in a Taylor's series,

x ox +1 &X LB 8x La
t 70 1! dat 2! qt tm! at
t=0 t=0 t=0

With Eq. (7) substituted for the derivative,

2.2
At At
= —— — ceoee
X= Xo
or

At .

X, =e X, (Q.E.D.) (8)
The "incremental solution" is
AT

Xigpg = € x (9)

A
where ¢ i the matrix exponential, is defined analogously to the
scalar exponential as

\2 3 k
AT oT are (Az)” az + {8 + (Az) (10)

CI kt
Id

in which I is the identity matrix

100 cesses O
010 essse O
0010 ...0

0 eoecsseesD 1

2.2 For Nonhomogeneous Equations

The matrix equation representing a system of first-order, constant
coefficient differential equations with nonzero forcing functions is
the nonhomogeneous equation

ax
at

where Z is the disturbance, or forcing function,vector.

= AX . Z, (11)

A general incremental solution of the nonhomogeneous equation

as derived by Liou! is

Co t+7 :
Xx, =x + ssf: Ag ar . (12)

An exact solution derived from Eq. (12) for the case where the

forcing function Z is constant over the interval t to t+t is

At At -
X,o=€ X + (7 -I)A 'z, . (13)

It is important to note that the inverse of A need not be calculated

to evaluate Eq. (13) since

(e Moat - + Aq + we?

wt

LB LK |

Toe TxD

il
HH
a
+
+

 

ol
o—
Ww
10

2
= T I+ at + Aol,

(ar)k-t
°* k! ’

oo k-1
: y Cn (14)
k=1

Because this series is similar to that used to represent AT,

the computer program can calculate the two required matrices

(Ar)! series equals

concurrently, since the kth term of the
the (k-1)th term of the AT series times (1/x). In the MATEXP
program, the AT matrix is called the "C" matrix and the (AT -1)a™t
matrix is called the "HP" matrix (in honor of H. Paynter).
At this point, two essential features of the matrix exponential
method are emphasized:
1. The exponential matrices can be computed by the series
approximation to nearly any desired precision (typically,
1 part in 10° is specified for MATEXP calculations). Hence,
for homogeneous equations and for nonhomogeneous equations
in which the forcing functions remain constant over the
computation time interval, the solutions are virtually exact
solutions. }
2. The solution vector can be updated successively by a time

increment 7 by two matrix multiplications:

X = C Xs + HP Z4

X,. = C X_ + HP Z.
ete
If it is assumed that just one time increment value 7 is
required, the C and HP matrices need to be evaluated only once.
An exact solution to the set of nonhomogeneous differential equations
can also be derived from Eq, (12) for the case where the forcing |
function Z varies linearly within the computation interval =<.

In terms of the matrix exponential series approximations, the
>

11

trapezoid forcing function incremental solution is

oO .
AT 11 k-1
Xp =€ Xp tT > kt cap (a7) Zn
k=1

2, k=l |
TT > GD)? Zetec ©. (15)

k=1

co 11
Liou = has also developed a recursive formula for accurate
approximations of continuous forcing functions which uses a Simpson's

rule approximation of the nonhomogeneous solution, Eg. (12), within

the time interval tT:

At T 21 At/2 T
Royo ™ € [x +82) +S € Zprfo * B Pr (16)

As with the case of the step-wise varying forcing functions, the
matrices required for Eqs. (15) and (16) need to be evaluated just
once at the start. These features are not presently included in the

MATEXP code, but could readily be added as options.

2.3 Miscellaneous Features of the Matrix Exponential

Since the matrix exponential principle has been a part of the
mathematical literature for many years, the matrix exponential has
had at least two other names: the fundamental matrix, and the
transition matrix. Besides the series approximation method, an

9

analytical method is often used to calculate this matrix; however,
the eigenvalues of A and their eigenvectors must be calculated and
the initial condition vector must be transformed by a matrix
comprised of the eigenvectors. It is emphasized that the series
method used in MATEXP does not require that the coefficient matrix
be nonsingular (i.e., have a nonzero determinant) or that its
eigenvalues be distinct (a case where the analytical solution has
terms of the form 1b and cannot be expressed as the sum of
exponentials). The latter condition, which occurs in problems

where two time constants in a decay chain are equal, was one of
12

the problems that Pease encountered in reactor burnup calculations
that prompted him to develop the matrix exponential method.”

Another feature noted by Pease (but not included in MATEXP) is
that the average solution vector X could be obtained directly from
a matrix exponential type calculation.

From the mean value theorem,
T

x -2[ X, dt,
0

X can be obtained by integrating the equation for X in terms of C
and HP:

 

T T
-_ 1 1 [ 1
= = = = + .
X 2 [, at : | cx (HP) Zy | at (17)
0 0
Term by term integration of the series approximations for C and
HP gives
T
2e 3
[oar=s Et +... l=, (18)
0
and
; 2
[mas STE Ae) +e |. (19)
0

The latter series, like the HP matrix calculation, could easily
be made concurrent with the other matrix exponential calculations.

The accuracy of MATEXP solutions, both in absolute terms and
compared with other methods, is difficult to estimate quantitatively
for the general case. Even for those cases that are solved "exactly,"
the successive multiplications of the solution vector by the matrix
exponential naturally tend to accumulate errors. However, with
precise calculations of the C and HP matrices as recommended in the .
Appendix, Sect. 5.1, test cases have shown this error to be negligible
for large systems (LO x 40), even after many thousands of updating
calculations. Liou! has developed an alternative method of evaluating
the C and HP matrices to a prescribed accuracy.

The nature of the matrix exponential method permits the use of
&*

13

much larger computation time intervals Tt than would be feasible for
most numerical integration solutions. For constant-coefficient
equations and a given 1, it would be safe to assume that MATEXP would
be inherently more accurate. As is usually the case, however, it
would be unwise to generalize about nonlinear equations. Nonlinear
solutions are discussed further in Sect. 3.4.

Eq. (20) gives a rough estimate of MATEXP solution times on the
IBRM-T7090 computer, assuming that a negligible time is spent in the

peripheral subroutines:

Solution time(min) ® 3.0 x 10° (NE)Z NT , (20)
where NE is the number of equations, and NT is the number of
computation time intervals. For éxample, a 59 x 59 system run for
1000 time steps took 10 min, and an 8 x 8 run for 10,000 ‘steps took
1.5 min. The solution time factor will vary from about 2 x 107° to
T x 107°, depending on the amount of extra subroutine computation and
printout, and will be approximately halved for homogeneous equations.

The present "standard" version of the MATEXP program solves up
to 60th-order equations and uses about 22,000 words of core storage.
In a 32,000 word computer, the extra 10,000 words emn be used for
special programming or storage, or the order of the equation’ can be
increased to about 80. Since, for larger problems, tape or other
slower storage devices would be required to calculate the matrix
exponential functions, the overall efficiency of the method would be
reduced. | |

Two other interesting, though perhaps purely academic, features
of the matrix exponential technique are that the solution time
increment can be negative (allowing one to go backwards) and that the

A matrix can contain complex coefficients.
3. DESCRIPTION OF MATEXP PROGRAM AND OPTIONS

3.1 Basic Input Information

The MATEXP program was written with the intent that it should

be easy to use for a wide variety of differential equation problems.
1h

Unfortunately, as a program becomes more general, i.e. the more
options and special features the program has, it becomes more difficult
to explain the program and to use it for any given problem.
Consequently, any apparent awkwardness and complications in the
following discussion are due to a desire to make it general, and any
omissions are due to a desire to keep it simple.

The basic parts of the code are: the main program, MATEXP; the
utility subroutine used for outputting, OUTPUT; and the subroutine
for calculating forcing(or disturbance )functions, DISTRB. To solve
linear, constant -coefficient differential equations that are
homogeneous (i.e. have no forcing functions) or which have only fixed
forcing functions, all the required data can be read in and no extra
programming is necessary. For equations of the form

& = AX +2,
the initial values of the X vector, the coefficient matrix A, and
the (fixed) disturbance vector Z may be read in. Other information
required for each run is the following:
1. number of equations,
2, initial time (or other independent variable),
3. computation time interval,
4, final time,
5. dnterval at which solution vector X and disturbance vector Z are
to be printed.

Since many elements of the coefficient matrix A are often zero,
only the nonzero elements need to be read in.. This makes it necessary
to identify each coefficient with its row and column number. The
nonzero values of the initial condition and fixed disturbance vectors,
with their row numbers, are read in similarly. |

Since successive runs might require no changes (or only a few)
in input data from the previous run, options are provided so that
only the altered data has to be read in.

An option is also available whereby the last value of the X vector

from one run can be used as the starting value of the succeeding run.
15

This option can be used if changes in the computation or printing.
interval are required in the middle of a solution or if certain
iteration or successive approximation schemes. are being used.

A complete description of the inputs and options is: given in

the Appendix, Sect. 5.

3.2 Alternative Methods of Generating the Coefficient Matrix A

Although the most straightforward method of inputting the
coefficient matrix is to read it in, very often it is advantageous
to have some or all of the elements calculated from system parameter
values. One option of MATEXP provides for this to be done by special
programming on the first call of DISTRB.. An alternative is to use
an "algebra table" routine developed by Kerlin and Lucius. 10 This
routine calculates the matrix elements from input parameter values
without any special programming. The general expression used for
calculating an element 2 4 in terms of parameters Pr and their

exponents Eq is

11 _ or Epp nl Eo, Bp 5 Eso Lp

E E E.. E
84 = C,Py B, Py cee By + CoP) P, 3 cel +
or m n
a,, =) Cg pK (21)
ij ¢
f=1 k=1

A complete description of the program is given in reference 16.

Beside the fact that it is sometimes convenient to have the
coefficient matrix calculated by the computer, in some cases computer
computation is almost necessary to obtain accurate solutions. This
was the case for one reactor dynamics calculation where the coefficients
were first carefully calculated on a 20-in. slide rule, then by the

machine. The difference in the steady-state solution for neutron

16p, W. Kerlin and J. L. Lucius, A Technique for Calculating
Frequency Response and its Sensitivity to Parameter Changes for Multi-

Variable Systems, ORNL-TM-1189 (June 1965).
16
level after a reactivity insertion was approximately a factor of 2.

3.3 Alternative Methods of Generating the Forcing Function Vector Z

When variable forcing functions are needed, a special program
must usually be written and included in DISTRB. Two special forcing
function subroutines have been written to simplify the programming:
DFG, for approximating arbitrary functions; and TRIG, for approximating
variable transport lags. They are both described in Sect. 3.5.

For cases where the forcing function is a solution to an ordinary
differential equation, this equation can simply be added to the system
matrix, and an exact solution can be obtained. As an example, assume
that a sinusoidal forcing function is used to excite a damped spring-
mass system. The quadratic equation that describes the displacement

y of the mass with time is

2 oo
dy +a Xs by = ¢ sin (wt + $) (22)
2 tat ©

where w is the frequency of the sinusoidal input (radians/time).

To arrange the equation in terms of first-order. derivatives, let

CNA
XE 3t J (23)
X, 2Y - (2k)
: 2, 2 Co
Solving for d7y/dt” (or dx, /dt), we obtain
dx,
= - ax) - bx, + c¢ sin (ot + #), (25)
and
dx,
2
x = Xq oe (26)
The equation for a pure oscillator with frequency w is
2
s+ afs=0. (27)
17

: ds
If we let xq = 30 and x), = ws, then
gy
&® CT (28)
ax,
Fralie w xq . (29)
If the initial conditions of xq and X) ‘are zero and -1, respectively,
then
x5(t) = sin wt , (30)
x(t) = =cos wt . (31)

Thus Cxq could be substituted for c sin (wt + &) in Eq. (25) The
required initial conditions of velocity x,(0) and displacement x,(0)
must also be specified.

The coefficient matrix for this example is

-a -b +c 0

+1
A= 0 “0
0) 0 +0 0

If the sinusoidal input were introduced as a forcing function, it
would appear as a stair-step approximation of a sine wave, and the
accuracy of the solution would depend on the accuracy of this
approximation. A comparison of the approximate and exact solutions
for a specific example is shown in Fig. 1. In the approximate
solution, a first-order extrapolation was used to approximate the
average value of the forcing function over the time interval.

In this example, the system has a natural frequency of 1.0
radian/sec and a damping factor of 0.25, and the driving sinusoid
has a frequency of 2.0 radians/sec. The computation interval of
0.5 sec for the approximate case gives about seven computations
per cycle of the driving function. Figure 1 also shows the response

after a long time where the excellent stability and accuracy of both
1.0 vy

ORNL DWG. 67-10215

 

51
Position
X2 0

J

 

—- 1.0 st

>

 

oo | ~ ) ~
| AN Maximum error in
. Time (sec) approximate solution = 0.014

Maximum error in initial transient - Exact MATEXP solution

©. approximate solution = 0.020

X Approximate solution, At = 0.5 sec

Fig. 1- Comparison of Exact MATEXP and Approximete MATEXP
Solutions for Sinusoidal Input to Damped
Spring-Mass System

 
19

solutions can be seen. This type of calculation is, historically,

very difficult to do with standard digital methods.

3.4 Methods for Solving Time-Varying-Parameter and Nonlinear
Differential Equations

It was shown in Sect. 2 that the MATEXP method can provide exact
solutions to sets of constant -coefficient, homogeneous differential
equations and to nonhomogeneous equations for which the forcing
functions can be represented by stepwise-varying functions. Since
forcing functions are usually smoothly varying, the accuracy of the
solution would naturally depend on the accuracy of the stair-step
approximations.

Likewise, in the case of time-varying-parameter, or nonlinear,
equations, the variations in the coefficient matrix A can be
approximated by stepwise variations. For a variable A matrix, however,
the matrix exponentials (C and HP) would both have to be re-evaluated
at each computation interval. Although this may still be an efficient
method for low-order equations (~10 or less), it could be quite
time consuming for larger problems.

A more efficient method of solution is to modify, or "fudge;"
the forcing function vector so that it compensates for the variation
in coefficients while the A, C, and HP matrices remain constant.

This is shown schematically in Fig. 2.

TR. A. Gaskill, "Fact and Fallacy in Digital Simulation,”
‘Simulation, 5 (5), 309- 313 (wv. 1965).
20

 

Nonlinear Equations

Z(t ) =p —> X(t) (Exact)

 

 

 

 

  

 

A= f(t,X)
+ z.(t,X)
Z(t) —— Ay X(t) (Approximate)

 

 

 

 

 

p fa—o

 

 

 

Fig. 2. Approximate Solution Using Fudged Forcing Functions.

Each component of the fudged forcing-function vector is calculated
by adding all the coefficient perturbation quantities in the row. For

example, assume one row of the matrix equation is

&

1

at = 1 (%) Xx, + 8p X 5 213 (t) *3 + z, (t) ’
where qq os and z, are variables and ayo is a constant.
Let _ 1

ay (8) = (ay)g + 2g;
and

—_ 1
213 (t) = (213) + 213 *

Then the equation can be rewritten .

dx

. |
T= laplg x tap x + (a

)

|
+2) +a x vagy xg .
_

= = 2,(t,x)

13°0 *3

 

Again, the forcing function z, would actually be smoothly varying,

but in the MATEXP difference equations, it is approximated by a

stair-step function.
21

For the case where the coefficients and/or the forcing functions
are known functions of time, much greater accuracy (for a given
computation interval Tt) results from using approximate mean values,
rather than initial values, of the functions in the computation
interval. First-order approximations of the mean values can be
obtained by evaluating the time-varying forcing functions and matrix
elements at (t + 7/2) instead of at (t). First-order extrapolations
of the mean values of the solution vector X should also be used

where coefficients are functions of X, as shown in Fig. 3.

Straight-Line
Approximation

 

 

 

 

 

 

> time

 

Fig. 3. First-Order Extrapolation of Mean Values of z and x at (t+3).

The use of an auxiliary subroutine VARCO greatly simplifies the
programming required to use first-order extrapolation calculations to
find approximate mean values of the forcing function.  VARCO is
described in detail in Sect. 5.2.

The only way of guaranteeing that the solution is accurate is to
reduce the computation interval tT until further reductions make no

significant difference in the solution. A simple, intuitive estimation
22

of the accuracy, however, may be obtained by noting the maximum amount
of change in the solution and coefficient values within a computation
interval. If these changes are only a few percent of the values of
the functions at the start of the interval, then the first-order
approximations will probably give very accurate answers. The true
accuracy of the representation of a nonlinearity should also be
considered when trying to "squeeze" too much accuracy out of a
solution. -

The use of fudged forcing functions for the solution of nonlinear
differential equations is very effective when relatively few of the
matrix coefficlents are variable. In this case one mi ght consider
the linear portion of the system of equations as being solved by an
extremely accurate analog computer, while the nonlinear portion is
simulated by a not=-quite-so-accurate computer. If most of the
matrix coefficients are variable, then the more conventional numerical
solution methods might be more practical than MATEXP.

More detailed discussions of the theory and use of fudged forcing
functions have been found disguised in sophisticated mathematical

treatises by Wolsto and Frazer et a1.

3.5 Special Forcing Function Subroutines

Since special programming is required in the DISTRB subroutine
to generate variable forcing functions for the differential equations,
two general purpose subroutines were written to facilitate this

programming for some problems.

3.5.1 Arbitrary Function Generation - DFG

 

The arbitrary function generation subroutine DFG provides a means
of generating approximations of single-valued functions of one

variable where the arbitrary function curve is represented by a

18
‘A. A. Wolf, "Some Recent Advances inthe Analysis and Synthesis
of Nonlinear Systems", Am. Inst. Elec. Engrs. transactions paper
No. 61-713.

Lr. A. Frazer, W. J. Duncan, and A. R. Collar, Elementary
Matrices, Cambridge University Press, 1957, pp. 232-45.
23

series of linear segments (Fig. 4). The principle is identical to
that of the diode function generator (hence DFG) used in. analog

computation.

Output

 

 

Fig. 4. Subroutine DFG Representation of an Arbitrary
Function of One Variable.

DFG in its standard form arbitrarily allows for up to 8 functions
with up to 32 points (or 31 line segments) per function. Inputs
required are the ordinate and abscissa values of the line-segment
end points. If more functions or finer approximations are required,
the dimensions could be changed easily. More details on the program

and a Fortran listing are given in the Appendix, Sect. 5.

 

3.5.2 Variable Transport lag Generation - TRIG

A transport lag (also known as a pure time delay, or dead time)
actually represents a distributed parameter system; hence, its
representation in a lumped -parameter solution will be only approximate.
The output z from a pure delay device with an input x and a fixed

delay time tT is
z(t) = x (t -1).

If tv is variable, then the relationship between z and x is a function
of the time history of =.
The variable time-delay problem is best illustrated by
fluid flow in a pipe where the inlet temperature and flow rate are
both variable. The assumptions required for a pure delay are:
1. there is no heat transfer to the pipe;
2. the fluid density is constant;
3. plug flow exists, i.e., there is no mixing of the fluid in the

direction of flow.
2h

The technique used in TRLG is to sample the inlet temperature x
and the flow rate W at each computation time interval T, thereby
keeping an inventory on each slug of fluid in the pipe. The total
weight of fluid in the pipe is computed from the initial transport
time 7, and the flow rate W:

P, tal (1b) = Ww, (1b/sec) x Ty (sec) .
Similarly, the weight of fluid that enters during each time interval
T is W(t) x T. Since the fluid density is constant, the weight of
fluid that leaves during that interval T is equal to the weight of
the inlet slug. | oo |

As an example, assume that the temperature profile in the pipe
is as shown in Fig. 5 and the slug at the inlet of AP, 1b is about
to enter. The slug at the outlet is ap at a temperature X where
AP > AP. When AP, enters, the outlet slug temperature will be
equal to X and the whole profile will be shifted to the right
by AP, 1b. The weight of the new slug just upstream of the exit
is then (ap - APJ)

If AF had been greater than AA the outlet slug would have taken
AP etc.) as

n-1’ n-2’
required (up to 300 samples), and the outlet slug temperature z

as much of the upstream inventory (i.e., AP

would be computed as the weighted average of the slug temperatures.
For example
AF = AP + 0.5 AP 4 ,

then so AP x + 0.5 oP 4 X 1

Z = ” .
AP + 0.5 AP.

If the maximum delay time (minimum flow rate) would use up too
many storage locations, the sampling would be done every other (or
every third, etc.) computation interval. With a variable lag, a ..
minimum expected flow rate must be specified to calculate how often
to sample.
The input variables supplied by the calling program for each call
of TRIG are XT (e.g., fluid temperatures) and the flow rates W (in
Inlet : Outlet

 

 

 

 

 

 

 

 

 

 

Temperature
x
TTT
|
vb | |
0 . i» P ;
Weight of fluid (1b) Co “total

Fig. 5, Temperature Profile of Fluid in Pipe.

“gz
26

terms of mass/time, unity for full flow, or some percentage of full
scale). The lagged functions ZT are returned by TRIG.
On the first call of TRLG, the flag NI should be zero, and the
following input data are read in:
NAGS
TI

WMIN = minimum expected values of flow W. for each function.

number of functions used,

fl

1]

initial values of transport lag time for each function,

The initial values of fluid temperatures in the pipes are set
equal to the initial values of inlet temperatures. If specific
initial temperature profiles are required, they can be read in with
only a minor change being required in the program. The standard
version of TRLG provides for wp to six lags with up to 300 samples
per lag. If more or fewer lags or points are desired, the statements
labeled DIMENS in the comment field can be changed accordingly.

© More details on TRLG and a Fortran listing are in the Appendix,
. Sect. 5.

There are two other techniques that are commonly used to represent
transport delays:

1. A series of n first-order lags, or "well-stirred tanks," with
time constants /n; oo
2. A Padé approximation which uses several terms of a series

approximation of eS (the Laplacian representation of a pure

delay), where S is the Laplacian argument. °
Both the series lag and Padé methods have accuracy and flexibility
limitations that would be prohibitive for certain problems .ot
Since the digital computer is quite proficient at sampling data,

- the sampled data approximation as used in the TRLG subroutine is

recommended as the most efficient and accurate method.

20a, E. Rogers and T. W. Connolly, Analog Computation in

Engineering Design, McGraw-Hill, N.Y., 1960, pp. 419-24.
21s. q. Margolis and J. J. O'Donnell, "Rigorous Treatment of

Variable Time Delays", IEEE Trans. on Electronic Computers, Vol.
EC-12, June 1963, pp 307-9.

<
3
27

ly. SUMMARY AND CONCLUSIONS

The matrix exponential method has a number of advantages over
the more common integration schemes for a large and significant class
of ordinary differential equation problems. The speed and accuracy
of MATEXP have the potential of reducing computing costs for large
problems and of making more 'real-time" computations feasible for
on-line digital computation, control, and optimization calculations.

The MATEXP program has been developed over a period of several
years, mainly through use in simulation problems. There are, however,
at least three other areas in which the matrix exponential method
might be effective:

1l. Automatic parameter estimation - where the parameters of the
model differential equations are adjusted to optimize the
agreement between theoretical and experimental response curves.
A computer program to implement this technique 1s currently
under development;

2. Solution of nonlinear algebraic equations by the method of
steepest ascents; and

3. Boundary value problems.

Other refinements that have been used with the MATEXP code
include the addition of an automatic plotting subroutine and a more
efficient output routine which prints only specified variables.
Forcing-function subroutines to solve implicit equations and
generate functions of two variables are planned as additions to the

"standard" package.
28 .
5. APPENDIX

5.1 Problems in the Evaluation of Exponential Functions

The Taylor series approximation for a scalar exponential function
is ; & Kk 2
€ NM Rokr SLtytord

2

r
Ft eee +, (5.1)

o-
w

This approximation also holds true when the argument y is a matrix;

hence, matrix exponential functions are amenable to digital computer
calculation, since raising a matrix to a power is a straightforward

operation.

It is important to note that the HP matrix calculation
HP = [exe (Ac) - 1]at (5.2)

does not require inversion of the A matrix, and can be calculated
directly from the terms of the C matrix approximation as shown
in Sect. 2.2.

There are several numerical problems associated with the matrix
exponential calculations. The approximations will be valid only if
1. the series will converge,

2. the numerical computation does not lose significance due to
overflow, roundoff, or truncation errors.

Since the evaluation of exp (At) requires calculating. powers of the

matrix At, there is a practical limitation on the maximum value of:

the largest element in the At matrix, and experience has shown that

it is most efficient to limit this value to about 1.0. Should the

desired tT make max |A,.t] > 1.0, then T is halved up to 10 times

i,J
for the exponential calculations. The original arguments are

 

restored by applying the following equations as many times as

required:
29

ol)

= exp (At)
. Co (5.3)
= exp (45) exp (45)
HP() = [exp (AT) -1] a
={ ES (3) 1) ek: + exp (5) | | (5.4)

There are also provisions in the code to keep track of the roundoff
errors in the exponential calculations. The maximum values of the

largest elements in the QPT matrices (hr) are monitored to make sure

that they are not larger than the specified precision "P" times

108 (for an eight-decimal computer). When the QPT terms are summed,

the accuracy of the summation will be approximately P, since the
summation is carried out until the largest element in QPT <P. If a
maximum value of a QPT element does exceed Px 108, then 7 is halved,
the exponential is calculated, and the original T is restored as before.

Users are cautioned that roundoff errors may become significant
if restoration of the original 1 requires very many applications of
the argument doubling Egs. 5.3 and 5.k4. We know of no general rules
for estimating this limitation; however, checks made on sample problems
indicate a "safe" boundary probably exists at a precision P = 10 ~ and
T halved 10 times. With a larger P and more halvings, one should at
least be cautious about the results.

The fidelity of the results are also questionable whenever the
ratio of the largest (absolute) matrix element to the smallest
(nonzero) element is > 10". This might be a manifestation of a very
wide range of time constants in a dynamics problem. With a range of
~ 10°, clearly the faster time constants could be considered
"instantaneous" with respect to the slower ones, and the equations

could probably be rewritten to get around this problem.
30.

5.2 Detailed Description of Programs

Hopefully the information given in this section is sufficient to
permit the reader to use and modify MATEXP. Since we have tried
going through this typically excruciating experience with programs
from others, we have tried making things as clear as possible. In
particular, we have used many comment cards in the program listings
as a running explanation of what we are doing. Either author would
be glad to try to help out any potential MATEXP user, and would be

happy to receive any suggestions for improving the program.

5.2.1 MATEXP Main Program

The MATEXP program consists of the main program and two sub-
routines. OUTPUT and DISTRB, plus any other subroutines called by
DISTRB. Even if DISTRB is not used, a dummy must be included.

For each case run on MATEXP, the data will include (if appropriate):

1. MATEXP Control Card,

2. Coefficient matrix (A),

3. Initial Condition Vector (XIC),

4, Any data read in by subroutine DISTRB,
5. Fixed forcing function vector (Z).

Input Data Formats - MATEXP Main Program

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

l. Control Card

Column | 1-2 6-7 11-20 | 21-30] 31-40 | 41-50] 51-60 | 61-62

Format | 12 |3X | I2 |3X| F10.0| F10.0 | F10.0 | F10.0| F10.0 Io

Input | NE IL P TZERO T TMAX PLTINC | MATYES
Control Card - cont'd

Column | 63-64 | 65-66 | 67-69 70 TI=72[ 73-7% | 75-80 |

Format | I2 I2 I3 | In I2 I2 F6.0

Input | ICSS | JFLAG | ITMAX LASTCC I1Z | ICONIR VAR

 

 

 

 

 

 

 

 

 

 

 
31

NE

LL = coefficient matrix tag number

number of equations

P = precision of C and HP - recommend 1076 or less

TZERO = zero time

T = computation time interval

TMAX = maximum time

PLTINC = printing time interval

MATYES = coefficient matrix (A) control flag
1 = use previous A and T

=-read new coefficients to alter A

= read entire new A (nonzero values)

DISTRB to calculate entire new A

= read some, DISTRB to calculate others

= DISTRB to alter some A elements

 ICSS = initial condition vector (XIC) flag

ON Ul = WwW nN
il

1 = read in all new nonzero values
= read new values to alter previous vector
= use previous vector

vector = O

vi oF Ww
I

= use last value of X vector from previous run
JFLAG = forcing function (Z) flag

1 thru 4 = same as for ICSS for constant Z

5 = call DISTRB at each time step for variable Z
ITMAX = maximum number of terms in series approximation of exp (AT)
LASTCC = nonzero for last case oo
J1Z = row of Z if only one nonzero, otherwise = O°
ICONTR ~- for internal control options

0 = read new control card for next case

1 = go to 212 call DISTRB for new A or T

-1 = go to 215 call DISTRB for new initial conditions

VAR = maximum allowable value of largest coefficient matrix element * T
(Recommend VAR = 1.0)
32

2. Coefficient Matrix A Format 4(213, El2.3) - Include if MATYES =

 

 

 

2, 3, or 5.
Column] 1-3 1-6 7-18
Format I3 I3 E 12.3 Repeat,
Input | Row No. Col. No. | COEFFICIENT 4 per card

 

 

 

 

 

 

 

Notes: 1. All row and column number entries on a card must
be nonzero.

2. Insert blank card after all coefficient matrix
data is read in.

3. Data can be entered in floating point (F)
format with decimal point. .

3. Initial Condition Vector XIC Format (I2, 5(13, E12.3))~ Include
if ICSS = 1 or 2

 

 

 

Column | 1-2 3-5 6-17
Format 12 13 E 12.3 Repeat Cols. 3-17,
Input MM Row No.| I.C. Value 5 per card

 

 

 

 

 

 

 

Notes: 1. A11 row number entries on a card must be nonzero.
2. Insert blank card after all XIC data is read in.

3. Data can be entered in F format.

4. Disturbance Vector Z Format (I2, 5(13, El2.3))- Include if
JFLAG = 1 or 2

 

 

 

Column 1-2 | 3-5 6-17
Format I2 I3 : E12.3 * Repeat Cols. 3-17,
Input KK Row No. 'Z Value 5 per card

 

 

 

 

 

 

 

Note: See notes under 3.

Two figures are included to aid in understanding the MATEXP
program. Figure 5.1 summarizes the data arrangement, and Fig.
5.2 is a flow diagram of the main program. The symbols used in
MATEXP are also listed and identified.
ORNL DWG. 67-10216
2 oc

MATEXP CONTROL CARD -
Case 2

 

 

 

Include if
JFLAG = 1 or 2

 

  
    
 

ICSS = 1 or 2 }

 

A COEFFICIENTS

   
 

MATEXP CONTROL CARD >
. MATYES = 2, 3, or 5

Case 1]

 

 

 

 

MONITOR
CONTROL CARDS

25

 

Fig. 5.1 MATEXP Data Arrangement

£c
34

ORNL DWG. 67-10217

 

NI: O FROM BOT TOM RIGHT
Fig. 5.2¢

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

FROM BOT YOM MIGHT
F16. 5.20

  

 

 

213]
WFLAGHO 10 TOP
OPTMP + P2108 Fio.5.2

PRINT CONTROL DATA
PLTING © PLTINC ¥.9999
JFK 0

 

 

 

Fig. 5.2a. MATEXP Block Diagram — Read or Compute A Matrix and XIC Vector.
 

35

FROM SOT TOM
Fig. 8.20

ORNL DWG. 67-10218

 

 

 

FIND AMAX 8 AMIN
"RATIO * AMAX / AMIN
T HALVED ISTOR TIMES
(UP TE 10) UNTIL
AMAX %# T C VAR

 

 

 

 

PEO
AL= 10
QPT + C

 

 

 

rR

—e] DO 16 KL = |, ITMAX |

KLM ». KL

ALL = T/AL

AL * AL+1

TALLL » T/AL

QPT = QPT¥* A % ALL
Cr C+QPT

 

 

 

 

 

HP ¢ HP + QPTHTALLL

 

 

 

47

 

IF

(QPTMP—PMK) D0

{PMK-P)

 

0,-
[14

1F
{ PE~-2% PMK )

Fig. 5.2b. MATEXP Block

 

[ PMKIABS (QPT{IMAX, JMAX)) ]

TO STATEMENT 37
F16, 5.2¢

 

PRINT KLM

TO STATEMENT 20
Fig.9.2C

 

a7

 

 

    

C(2T) = CITIEC(T)

 

418

 

  

HP(2T) » HP(T)+CITINHP(T)

 

 

 

 

 

 

 

 

 

1STOR:
1STOR+JFK [1414
+0
’ IF
IF .
Tmax Dba IKLM-N |=

-1) 838 \ITMAX

0,-

 

Diagram — Compute C- and HP Matrices.
36

ORNL DWG. 47-10219

FROM RIGHT SIDE
FIG. 5.2b

 

 

 

 

 

 

 

 

 

 

 

 

 

 

  

20
TIME TZERO
PLT:0
6 ! Go TO 55 83 {uatves O- 215
JFLAG -3)
2:0 4
28 +
121
Al [ xxe0 CALL 0ISTRB
READ Z 20 1ST CALL
27
CALL OUTPUT
I ST CALL
(NI SET #t)
24
CALL DISTRB

  
 
 
 

 

 

 
 

0,—=
700

cwxsient |
fs2

SOLUTION
Xs¥Y

i

|
FLAGS TOSTATEMENTI | TO STATEMENT 212
£16.5.20 F16. 5.20

 

 

 

 

 

 

 

 

 

 

TIME * TIME+T

PLT=PLT4T Go)

 

 

 

   

 

    

 

 

 

 

 

 

IF
(PLT-PLTINC) IF

ICONTR
PLT=0

KeK+i

$33 NI O

FROM BOTTOM
FIG. 8.2b

 
  

 

 

7

 
 

Fig. 5.2c. MATEXP Block Diagram — Compute Solution Vector.
37

MATEXP MATN PROGRAM SYMBOL KEY

 

1.

2.

3.

Control Card Inputs

See input data format list.

Input Data
A(NE,NE) = coefficient matrix

MM = initial condition vector tag number
XIC (NE) = initial condition vector
KK = disturbance vector tag number

Z(NE) = disturbance vector

"Internal Variables

The following variables are listed in alphabetical order.

ADT = AMAX x T

AL = Floating point KIM for ALL calc, KIM+l for TALLL

ALL = T/AL with AL = KIM |

AMAX = Maximum (absolute) value of element in A matrix

AMIN = Minimum (absolute) value of nonzero element in A matrix
C(NE, NE) = Coefficient matrix exponential

HP(NE,NE) = Disturbance function matrix exponential

IMAX = Row location of AMAX

IMIN = Row location of AMIN

1

ISTOR = Number of times matrix exponential argument T is
halved so that AMAX x TCVAR; later ISTOR = ISTOR + JFK

JFK = Number of times T is halved in order for matrix exponential
calculation precision to be P or better

"JIFLAG = Flag to prevent double call of DISTRB during initial
time step calculation

Column location of AMAX
Column location of AMIN

JMAX
JMIN

K = Case number

KIM = Number of terms. in series approximations of exponentials

"NI = Printing flag: O on initial call of OUTPUT causing printout
of A, C, and HP matrices, OUTPUT sets NI = 1 on first call.

PE = Maximum element in. (n - 1)th QPT term
PMK = Maximum element in meh QPT ‘term
38

QPT(NE,NE) = Term in series approximation of C matrix

PIMP =
BATIO =

TALLL =
TQP(NE)
X(NE)
Y(NE)

Maximum permissible value of element in QPT matrix.
AMAX/AMIN. If RATIO less than 10° (for eight decimal
machine) there may be significant problems in
calculation of C and HP. oo

T/AL with AL = KIM +1

= Temporary storage for QPT terms

= Solution vector

= Temporary storage for X

5.2.2 Subroutine OUTPUT

The first time MATEXP calls OUTPUT, the coefficient matrix (A)

and the exponential matrices C and HP are printed out, along with the

_initial solution (X) and disturbance (2) vectors. OUTPUT also sets

the first call flag (NI) to 1, and on subsequent calls only the X

and Z vectors are printed. A possible means of saving computing

time at the expense of storage would be to store X (and Z) values

in arrays for a large number of time intervals,. then print the

“arrays out in blocks. Additional savings could be achieved by

printing only selected variables.

5.2.3 Subroutine DISTRB

Subroutine DISTRB may be called by MATEXP either to compute
matrix coefficients (A) on the first call (i.e. when flag NI = 0)

and/or compute variable forcing-function vectors (2).

Other special purpose subroutines, such as VARCO, DFG, TRLG,

and any others the user may want to supply, are usually called by

DISTRB.

‘Another special purpose use of DISTRB is to compute inputs

for successive MATEXP cases without requiring a control card for

each case. This is done by means of the flag ICONTR (Cols. 73-4 on

the control card). After a case is run, the first call flag NI is

reset to O, and case number K is increased by 1; then if ICONTR

is positive, DISTRB will be called at statement 212, where a new
39

coefficient matrix A or time interval T may be calculated. If
ICONTR is negative, DISTRB is called at statement 215, permitting
new initial conditions to be used.

The program listing for DISTRB that was used in calculating the
sinusoidal forcing function for the example in Sect. 3.3 is given
in Sect. 5.3.

Another version of DISTRB is used to calculate the sensitivity
of a system's time response to changes in the system's coefficient
matrix elements

aX .

da, .
1d

 

. DISTRB controls the solution of the system equations and stores
those values of the solution vector which are to be used subsequently
as forcing functions for the sensitivity calculations. To campute
the sensitivity to 2; 37 the 5B row of the system solution vector
is stored and is later used as a forcing function to the i row of -
the same system equations.”

After solving the system equations and storing the required
elements of the response vector, the arithmetic average values of
the X's in each time interval are calculated and stored (XT).

During each sensitivity run, DISTRB feeds the forcing function
into the system equations, and the resulting printouts of the X
vectors are the desired sensitivities.

For the sample program shown in the Fortran listing, Sect. 5.3,
the system is forced by a unit step input in row I1Z (specified on

the control card). Other control card inputs are:
JFLAG = 5

ICONIR = 1

Special input data read in by DISTRB are the row (IS) and column
(JS) numbers of the matrix elements for which sensitivities are to
be calculated, the number of time points (NTS), and the number of

sensitivity runs (NSENS), as follows:
 

1 1 51
fs) | as | x) | 18(2) | 3s(2) | (uX)f...thru Js(5) }NrT | NSENs]

 

I3 I3 I3 I3 I3 13

5.2.4 Subroutine VARCO

The VARCO (VARiable COefficient) subroutine can be used with
DISTRB to simplify the programming of problems with variable coefficient
matrix elements. In general, these elements are functions of both
time and the values of the solution vector X. VARCO is designed to be
called by DISTRB at the start of each computation interval and to
return the mean values of time (TX), and X, (XTR), for that interval.
The mean values of X are predicted by a first order extrapolation
scheme, as shown in Fig. 3. VARCO will also cause the initial time
step to be repeated, using the first try at calculating X(T) to
estimate the mean value at z. DISTRB can then calculate the
coefficient values using TX and XTR. Use of this first-order
extrapolation scheme results in significant improvement in accuracy

over using no extrapolation.

5.2.5 Subroutine DFG

DFG uses the principle of the analog computer's Diode Function
Generator (see Fig. 4) and uses linear interpolation to approximate
arbitrary, single-valued functions of a variable. Data for DFG is
read in the . first time it is called by DISTRB (i.e., when NI = 0).
The standard program provides for up to 8 functions with up to 32
coordinates each. oo

On each successive call, DFG returns the functions ZD for
varying inputs XD. If an input XD(I) goes outside the specified
limits, the output is a straight-line approximation of ZD(I) based
on the slope of the function at the boundary, and an error message
"DFG(I) RANGE EXCEEDED" is printed.

The inputs read in by DFG are:

NDFGS Number of functions used

NPTS(8) Number of points in approximation for each function
41

XP(32,8) Independent variable points ..-
ZP(32,8) Dependent variable points

The input format is as follows:

Card No. 1 (I2, 8X, 8I3)

 

 

 

 

 

 

 

 

 

 

Column 1-2 11-13
— Repeat Cols, 11-13
Format I2 8X I3 .
7 more times for
Variable | NDFGS NPTS(1) | NPTS(2) to (7)

Card No. 2, 3....etc. (8E10.3) oo

Column 1-10 11-20 21-30 31-10 Repeat as required
Format E10.3 E10.3 E10.3 E10.3 | for DFG(1l); Max.
Variable | X0(L,1) | z8(L,1) | xB(2,1) | zp(e,1| 8 numbers per card

 

 

 

 

 

 

 

 

 

 

NOTES: 1. When all data for DFG(L1) has been entered, start
DFG(2) data on new card; etc.

2. Enter independent variable points XP in order,
progressing from most negative to most positive
values.

3. F Format entries (with decimal point) may be used.

5.2.6 Subroutine TRLG

TRIG (TRansport LaG) is described in some detail in Sect. 3.5.
~ The input functions XT (e.g. fluid temperature) and the mass flowrates
W (in terms of either mass/time, unity for full flow, or some
percentage of full scale) are supplied by the calling program DISTRB,
and the lagged functions ZT are returned by TRLG. On the first call
of TRLG (when NI = 0), the following input data is read in:

NLAGS Number of functions used

TI(6) Initial value of transport lag time for each function

WMIN(6) Minimum expected value of mass flow W for each function

The program is set up assuming that subroutine VARCO is also
called by DISTRB. VARCO has a restart feature which repeats the
initial time step calculation; thus the TRLG functions will not be
updated on the second call. If VARCO is not used, this second call

 
h2

omission may be deleted by removing statement 33 in the TRLG program.
The input format for TRIG is:

Card No. 1 (I2)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Column 1-2

Format I2

Variable | NLAGS

Card No. 2 (6E10.3)

Column 1-10 Repeat 5 moref
Format E10.3 times for
Variable TI(1) TI(2) - (6)
Card No. 3 (6E10.3)

Column 1-10 Repeat 5 more
Format E10.3 times for
Variable | WMIN(1) WMIN(2) - (6)

 

 

 

 
-43-

5¢3 + FORTRAN LISTING OF PROGRAMS

$IBFTC MAIN DECK

AA COON NNO NNNON CANON NNANNONO NNO ONONONO ANACONDA ANAN

PROGRAM MATEXP FOR THE 7090 - FORTRAN 4

THIS PROGRAM CALCULATES THE SOLUTION OF A MATRIX OF FIRST
ORDERs SIMULTANEOUS DIFFERENTIAL EQUATIONS W/ CONSTANT COEFFICIENTS

OF THE FORM DX/DT # AX + Ze
THE METHOD IS PAYNTER-S MATRIX EXPONENTIAL METHOD

THE SOLUTION IS GIVEN FOR INCREMENTS OF THE INDEPENDENT
VARIABLE (T) FROM TZERO THROUGH TMAX

COMPUTES MATRICES C # EXP(A¥T) AND
HP # (C-I1)*A INVERSE
SOLUTION X(N#T) # CH*X((N—1)*T)+HP*Z ((N-1)*T)
SERIES CALCULATION OF C AND HP MONITORED TC
ASSURE SPECIFIED SIGNIFICANCE.
IF T IS REDUCED FOR -C AND HP CALCSes
CRIGINAL ARGUEMENTS ARE RESTORED BY -
C2%¥TH#C(Ty=*C (Ty
HP (2% T)#HP(T)+C(T)*HP(T)

OUTPUT FROM THE PROGRAM IS PRINTED AT INTERVALS PLTINC.
THE PROGRAM USES SUBROUTINES DISTRB AND OUTPUT

INPUT FOR THE PROGRAM CONSISTS OF
~ "ONE CONTROL CARD
THE COEFFICIENT MATRIX A (UP TO 60 X 60) - DIM
THE INITIAL CONDITION VECTOR X
A FIXED DISTURBANCE VECTOR Z

A VARYING Z CAN BE GENERATED BY DISTRB
VARIABLE COEFFICIENT EQUATIONS MAY BE SOLVED BY APPROPRIATE
FUDGING OF THE DISTURBANCE FUNCTION SUBROUTINE.

CONTROL CARD INPUT INFORMATION

NE#NO. OF EQUATIONS (12)
LL#COEFFe MATRIX TAG NCe (12) :
P#PRECISION OF C AND HP (Fi0e0) —- RECOMMEND {e+0E-6 OR LESS
TZERO#ZERO TIME (F100)
T#CCMPUTATION TIME INTERVAL (FI0.0)
TMAX#MAXIMUM TIME (F10e0)
PLTINC#PRINTING TIME INTERVAL (F100)
MATYES#COEFFs MATRIX (A) CONTROL FLAG (12)
I #USE PREVIOUS A AND T
2#¥READ NEW COEFF.S TO ALTER A
3¥READ ENTIRE NEW A (NON-ZERO VALUES)
4#DISTRB To CALC. ENTIRE NEW A
5%¥READ SOMEs DISTRB TC CALCs OTHERS
6#DISTRB TO ALTER SOME A ELEMENTS
1CSS#INITIAL CONDITION VECTOR (XIC) FLAG (I2)
| #READ IN ALL NEw NON-ZERO VALUES
2H#READ NEW VALUES TO ALTER PREVIOUS VECTOR
3#USE PREVIOUS VECTOR
LEVECTOR#D
ONO OY OY

x

Cy OY OY

aNaNA)

“ha

S#USE LAST VALUE OF X VECTOR FROM PREVIOUS RUN
JFLAGHFORCING FUNCTION (2) FLAG (12)
| THRU 4#SAME AS FOR 1CSS FOR CONSTANT Z
S#CALL DISTRB AT EACH TIME STEP FOR VARIABLE Z
I TMAX # MAX. NOo OF TERMS IN SERIES APPROX,
OF EXP(AT)s (13)
LASTCC # NON-ZERO FOR LAST CASE (11)
112 # ROW NCe OF Z IF ONLY CNE NON-ZERO»
OTHERWISE #0 (12)
ICONTR —= FOR INTERNAL CONTROL CPTIONS (12)
O¥READ NEW CONTROL CARD FOR NEXT CASE
I#GO TO 212 CALL DISTRB FCR NEW A OR T
~1#GO TO 215 CALL DISTRB FOR NEW I.Ce-S
VAR # MAX. ALLOWABLE VALUE OF LARGEST COEFFe MATRIX ELEMENT * T
(RECOMMEND VAR#! +0) (F640)

DIMENSION A(60560)»C (60560) sHP (65260) sQPT (60560) »
IX(60)sY(60)+2(60)sXIC(60),TQP (60)

COMMON CsHPsAsQPTsXsZsYs ITMAX KKsLL s MM,
VJIFLAGXICYNIs TIMES TMAX 3s TZERC SNES TQP Ts
211Z9sICONTRsPLTINCIMATYES» ICSS 3 JFLAGSPLT

K#CASE NUMBER
NI#0 ON |-ST PASS. SET TO | ON I=-ST CALL OF OUTPUT.
K#I
NI#0
J READ (5.100) NEsLLsPsTZEROs Ts TMAX sPLTINC yMATYES»1CSSs

| JFLAG, ITMAX sLASTCC» 1125 1CONTRsVAR
100 FORMAT (2(12+3X)s5F 10e093129135119212sF64C)

COEFFICIENT MATRIX INPUT
GO TO (34995292243) sMATYES
2 DO 90 I1#I| NE
DO 90 J#! SNE
90 A(IsJ)#0.D
IF(MATYES-4)9943499
99 DO 91 1#1s1379
MATRIX ELEMENTS 5(ROW, COLUMNS VALUE)
ALL I AND J ENTRIES ON CARD MUST BE NON-ZERO.
A BLANK CARD IS REQUIRED AFTER ALL ELEMENTS ARE READ IN.
READ (55101) I1eJl sD s129J29D29139J3sD39149J4sD4
10! FORMAT (4(213sE1243))
IF(I1)3293492
92 AlI1,J1i#DI
ACT29J2)%D2
ACI3,J30#D3
91 ACL4 Joly #04

INITIAL CONDITION VECTOR XIC INPUT
3 GO TO(4s 120969596) s1CSS
4-DO 93 I1#14NE
93 XIC(I)#0.0
120 DC 94 I#1415
ALL ROW (1) ENTRIES MUST BE NON-ZERO
A BLANK CARD 1S REQUIRED AFTER ALL ELEMENTS ARE READ IN.
READ (5495) MMe I 11 sDt1s1124D125sT1340134114+D14,1154D15
95 FORMATI(I1245(134E12e3})

 

DIMEN
DIMENS
Ov OY OV Oy

0

96

94

81
82
214
212
213

211

-45-

IF (1111696996
XIC{IIIY#DI |
XIC(II2)#D12
XIC(II3#D13
XIC(I14)#D 14
XIC(II5)#D15

MM#0
DO 7 I#1sNE
XIC(I)#0e0

IF(ICSS=5)814214,81

DO 82 I#I 4NE

X(IY#XIC(T)

IF(MATYES=3)21352135212

CALL DISTRB

JJIFLAG#O : :

QPTMP # MAX. PERMISSIBLE ELEMENT OF QPT FOR 8 DECIMAL COMPUTER

MATRIX CALCe LOSES SIGNIFICANCE IF LARGEST
ELEMENT IN SERIES APPROX. MATRIX QPT IS
GREATER THAN P¥*|.CES8

QPTMP#P* | +(JE8

WRITE (69211) KeNEsP oT
IPLTINCyMATYESs1CSSsJFLAGs ICONTR ITMAXs 112 VAR »QPTHP

OF ORMAT ( | 2HIMATEXP CASE,I13/17H NOe OF EQUATIONS,
113720H SPECIFIED PRECISIONsF1248/6H TIME

28HINTERVALsF1848/15H PLOT INCREMENT sF|7e8//

316H CONTROL FLAGS =/1IH 35Xs6HMATYESs14/ IH

L5Xs4HICSS»16/ 1H $5Xs5HJUFLAGsI5/ 1H s5Xs6HICONTR,14/
534HOMAXe TERMS IN EXPONENTIAL APPROXes15/

806

402

401

407
408

6!3H SINGLE Z ROW,sI14/20H MAXe ALLCWABLE A#DTsF9.3/
727TH MAXe ALLOWABLE QPT ELEMENTSFl1e3)

PLTINCHPLTINC*0.9999

JFK#0

IF(MATYES-1)20+20,806

SCAN MATRIX FOR MAXe AND MINe NON-ZERO ELEMENTS.
IMAX# |

JMAX# |

AMAX#ABS (A(1s1))

DO 4p! I#14NE

DO 40! J#! SNE

IF(AMAX~ABS (A(1sJ)))402+401 9401
AMAX#ABS (A(IsJ})

IMAX#I :

JMAX# J

CONTINUE

IMIN#IMAX

JMIN#IMAX

AMIN#AMAX

DO 409 I1#1 4NE

DO 409 J#I1 NE

IF(A(TSJ)) 40794099407

IF(ABS (A(I+J))~-AMIN) 408,409,409
AMIN#ABS (A(IsJ))

IMIN#I

JMIN#J
Oy ON

ay (YO

3

)

[4B]

409

413
403
404

405

410

-h6-

CONTINUE
RATIO#AMAX/AMIN
AMIN # MINIMUM NON-ZERO ELEMENT
I STOR#D
ADT#AMAX*T
DO 403 I#1,s11
IF(VAR-ADT) 41354045404
[STOR#¥ISTOR+I
ADTHADT#0 45
T#ADT /AMAX
COMPUTATION INTERVAL T IS HALVED ISTOR
TIMES ()g#MAXe) SO MAX. ELEMENT IN A*T
IS LESS THAN VAR.
WRITE (64035) IMAX 9s JMAX s AL IMAXs JMAX) s ADT oT
| IMINsJMIN,A(IMIN,JMIN),RATIO
FORMAT (3 |HOMAXeCOEFFe MATRIX ELEMENT # A(sI1251Hs351293H) #»
|. EI15e4/ 13H MAXe A%DT # oF 12e¢842Xs 1 4HWITH DELTA T #,Fi548/

230HOMINIMUM NON-ZERO ELEMENT # A(s1231HesI2s3H) #sE15e4/
318H RATIO AMAX/AMIN #sEI15,.,4)

IFLISTOR-1018s410,410
WRITE (69411)

41 1 pFORMAT ( 34HOA#DT STILL GREATER THAN ‘ALLOWABLE »

48

49

j 19H AFTER 10 HALVINGS.)

GO TO 37

CALCULATION OF MATRIX EXPONENTIALS C AND HP
DO 9 I1#1 sNE

DO 9 J#I NE

C(IsJ)#De

DO 1D I#1 NE
ClIsIN#Iloe

SKIP HP CALCS. FOR HOMOGENEOUS EQUATIONS
IF (JFLAG-4)48,51,48

DO 49 1#1 NE

DO 49 J#1sNE

HP (I+J)#Q.o

DO 50 I#I,NE

50

51

HP (IT, 1)#T

PE#0.0

DO || T#1 4NE.

DO I J¥I sNE

QPT(IsJ)#C(1sJ)

FORM THE MATRIX EXPONENTIALS CHEXP(A%¥T) AND HP#((C-I1)%A INVERSE)
AL#1 e0

DO 16 KL#IsITMAX

KLM#KL

CALL#T/AL

AL#AL+1 0
TALLLAT/AL

 

i eel am
ONO

COON

[aNaNe!

| 8

44

45
145

46

FIN

17
16

21

iy

DO 18 I#! 4NE

DC 13 J#14NE

TQP(J)Y#0e0

PC 13 KX#14NE

TQP (UY #TQP(JY+QPT (I sKX)*¥A(KXs J)

DO 18 J#I| sNE
QPT(IsJ)ETQP (J) *ALL

QPT#MATRIX TERM IN SERIES APPROXe #((A¥T)%*%K)/K FACTORIAL

DO 44 I#1 NE
DO 44 J¥I SNE
CUIsJIECII,0)+QPT (15)

IF (JFLAG=4)45447445

IF(ITMAX=KL)4T 9474145

DO 46 I#! sNE

DO 46 J#1 NE

HP (Is J)#HP (Is J) +QPT(IsJ)*TALLL

D MAX ABS ELEMENT IN QPT AND CALL IT PMK

LARGEST QPT ELEMENT USUALLY IN ROW IMAXs COLUMN JUMAX

PMK#ABS (QPT(IMAXsJMAX))

IF(QPTMP-PMK) 83,83+502

IF(PMK=P) 4063406416

SCAN OTHER QPT ELEMENTS ONLY WHEN QPT(IMAX, JMAX) IS LESS THAN P
DO 14 I#! NE

DO 4 J#!| sNE

PMK#AMAX 1 (PMKsABS (QPT(1IsJ)))

IF(PMK=P)17s17516

PRESENT MAXe QPT ELEMENT. SHOULD BE LESS THAN
HALF PREVIOUS MAXe TO INSURE CONVERGENCE

IF(PE-2+%PMK) 16921921
PE#PMK
WRITE (6200) KLM

200 FORMAT (44HONCe OF TERMS IN SERIES APPROXe OF MATEXP # 412)

538

“83

304

303

303

210

IF(ITMAX=1)20s20+538

IF(KLM=1TMAX) 4144583,83
TH#T*0e5

JFKH#JIFK+I

IF (JFK~7)30353045304

WRITE (6305) PMK

OFORMAT (32HD7 TRIES AT HALVIMNG T NeGes PMK#sF 1246)

GC TO 37

WRITE (6210) KLMsPMK oT
FORMAT (2 IHOMAXe ELEMENT IN TERM,I13,8HOF QPT #sEIlle3/
I 35H TRY HALVED TIME INTERVAL DELTA T #,F15.8)

GO TO 8
-L8-

414 ISTOR#ISTOR+JFK

C ORIGINAL ARGUMENTS OF C AND HP MATRICES RESTORED IF ISTOR GREATER THAN O ,
IF(ISTOR) 2020416
416 WRITE (635415) ISTOR

415 FORMATI(26HOTOTAL NCe OF T HALVINGS #4513)
DO 417 KR#|,ISTOR :
IF(JFLAG=4) 41994185419
C SKIP HP CALCS. FOR HOMOGENEOUS EQUATIONS
419 DO 420 I#I1,4NE
DO 421 J#1 NE
TQP (J) #00
DO 421 KX#I sNE
421 TAP(JIATQP (J) +HP (I sKX)*C (KX J)
DO 420 J#I1 4NE
420 HP (Is J)#TQP(J)+HP (1s J)

418 DO 430 I#1,4NE
DO 430 J#! SNE
430 QPT(I+sJ)#0.0
DC 431 I#I14NE
DO 431 J#! 4NE
DO 431 KX#| NE
43) QPTUI 9s JI#QAPT( 19d) +C(I19KX)*¥C(KXsJ)
DO 432 I1#IsNE
DO 432 J#I4NE
432 CIs JIHQPT (I,J)
417 T#2e0%T

C(IsJd) IS THE MATRIX EXPONENTIAL CHEXP(A*T)
AND HP (IsJ) IS THE ((C~-1)*A INVERSE) MATRIX
NOW WE READ (OR CALL SUBROUTINE FOR) DISTURBANCE VECTOR

ONO N

20 TIME#TZERO
PLT#Oe
GO TC (265121327 925955) 3 JFLAG
55 IF (MATYES=3)2155215427
215 CALL DISTRB
I1Z#112
GO TO 27

26 DO 97 I#14NE
97 Z(1)#0.0
121 DO 98 I#1415 :
C ALL ROW (I) ENTRIES MUST BE NCN-ZERO
C A BLANK CARD IS REQUIRED AFTER ALL ELEMENTS ARE READ IN.
READ (5595) "KKsI219D2191224sD2251234D239124sD2451254D25
IF(I21)27527478
78 Z(I121)#D21
211224022
Z(123)#D23
201244024
98 2(125)#%D25

25 KKAD
DO 28 I1#!sNE
28 Z(1)80. |

C ON 1-ST CALL OF OUTPUT NI SET TO |
27 CALL OUTPUT :

 
NOOO

NN NnN

53

56
30
29

702
703

700

32
52
31

ONE
NOW

33
35

37
34

40

-k9-

COMES THE EQUATION SOLUTION BASED ON
XINT)#MEX(NT=1)+((M=1)A INVe)*Z(NT~1)

IF (JFLAG=4)29+544+56

DO 53 I1#I14NE

YUIVHCt Is) #XU1)

DO 53 J#2sNE

YCI)AY (TI) +C (Ted) %X (J)
IF(112)52+524,702

IF{JJFLAG) 3092930

CALL DISTRB

IF(11Z2)700+s70054

ONLY ONE Z-TERM CALC, IF 11Z IS GREATER THAN ZERO
DO 703 I1#1 NE

YOIIAY(I)+HP (Is 11Z)%Z2(112)

Go To 52

DO 32 I#!sNE
YUIYHC(TI ol) #X UI) 4+HP (Ts 1) %2 (1)

DO 32 J#2sNE :

YOY (I) +C (Tod) ¥X (J) +HP (TJ) *Z (J)
DO 31 1#I| sNE

X(Iy#Y (I)

TIME INCREMENT OF THE SOLUTION HAS JUST BEEN FOUND
PLCT AND PRINT IF PLTINC INTERVAL HAS ELAPSED

JJFLAG#I

TIME#TIME+T

PLT#PLT+T
IF(PLT-PLTINC) 35433533
CALL OUTPUT

PLT#0

IF(TIME~-TMAX 24537937
IF(LASTCC)40s 34940
K#K+ |

NI#0

PLT#00N .
IF(ICONTR)215s19212
STOP

END

 
-50-

$IBFTC OUT DECK
SUBROUTINE OUTPUT

DIMENSION Al60+63)9C (60560) sHP (60960) sQPT(60+60) DIMENS
1X60) sY (60) 92(60)sXICLET)sTQP (60) } - DIMENS

COMMON CoHPsAsQPTX9ZsYs ITMAX 9KKs LL MM,
| JJFLAGsXICsNI s TIME» TMAXsTZERO SNES TQP 4 T
211ZsICONTRsPLTINCsMATYES» ICSSsJFLAGSPLT

IF(NI)2s1 92
I NI#I

NC#10

DO 11 NCMEIsSisl0

WRITE(E69200) LL ((ACIsJ) s JENCMSNC) s I #1 sNE)
200 FORMAT (2HOAsI2/ (1H I1PICE!Il«2))

TF(NE=NC) 10s10s11
Il NCENC+I10

10 NC#InD
DC 21 NCM#I +5110 : :
WRITE(S5+201) ((CUIsJ)sJHNCMINC)sI#14NE)
201 FCRMAT (2HOC/ (IH 4IPIDEIl42))
IF(NE-NC) 20920921
21  NC#NC+I10O

20 NC#ID
DO 31 NCM#1451410
WRITE(69202) ((HP(IsJ) es JH¥NCMsNC)sI#1sNE)
202 FORMAT (3HOHP/(1IH sIPIDELI13))
IFINE=NC) 242521
31 NCHNC+10

2 WRITE(69203) TIMES (X(I)sI#I1sNE)
203 FORMAT(4H T #,IPEICe2s4H X #5 / (IH 5X 10E11e3))
[F{JFLAGeNELS) GO TO 20

WRITE(65204) (Z(1)sI#1sNE)
204 FORMAT (6HOZ # S1IPIOEIT43/(1IH 35XsICEIle3))
30 RETURN
END

 
-51-

$IBFTC sSuBz DECK
SUBROUTINE DISTRB
C
C DISTRB FOR REPORT EXAMPLE
C
DIMENSION A(60+60)sC(60+60)sHP (6060) sQPT (60:60)
IX(60)sY(60)s2(60)sXICL6N0)sTQP (60)
COMMON CoHPsAsQPT 9X 9ZsY 3s ITMAX sKKsLL s MM,
| JUFLAGsXICsNI os TIMES TMAX 3s TZERO SNE» TQP oT
211 Z+sICONTRSPLTINCyMATYESs ICSS 4 JFLAGSPLT
C } :
TX#TIME+Qe5%T
ZUV)YHSIN (2.0%TX)
RETURN
END

$IBFTC DSENS DECK
SUBROUTINE DISTRB
C DISTRB FCR TIME RESPONSE SENSITIVITY CALCS.
DIMENSION A(60+60)sC (60560) 9sHP (60960) 9sQPT(60s60}
IX(60)sY(60)s2(60)sXIC(60)sTQP (60)
COMMON CsHP sAsQP TeX 9ZsYs ITMAX sKKsLL s MM,
| JJFLAGsXICoNI os TIME s TMAX 3s TZERO SNES TQP Ty
21 1Z+sICONTRsPLTINCesMATYES s ICSSsJFLAGSPLT
DIMENSION IR(5),I5(15)4JS(15),1Q(30)sXT(5,1000)
IXSEN{(15+30) +XPSI(30)
IFINI)Ts14e2
| IF(ICONTR+2)54+443
2 IF{ICONTR+42)7+646
C INITIAL INPUTS AND CALCS.
3 READ (54100) (IS(1)sJS(1)sI#195)sNTIsNSENS
100 FORMAT(6(213s4X))
NDT #1
ICONTR#=-2
NTIMO#NTI-|
DO 8 I1#1 NE
8 Z(I11#0.0
C DURING SOLUTION OF SYSTEM EQUATIONS
6 DC 20 I#1sNSENS
ICO#JS(T)
20 XT(ISNDTIH#X(ICO)
NDT#NDT+ I
GO TO 30

C JUST AFTER SYSTEM SOLUTION IS COMPLETED
4 1STH#D
ICONTR#-3
DO 21 I#1 sNSENS
DO 21 J#I sNTIMO
. 21 XTUI oJ) #0eB%*(XT(IesJ)+XT(IsJ+11))
ae XT # AVG VALUES OF SENSITIVITY EQN INPUTS

WRITE(65102) ((XTCIsJd) oH oNTI) os I#1 9NSENS)
102 FORMAT(3HOXT/ {1H 4I10El]l«3))
C
C AFTER COMPLETING EACH SENSITIVITY RUN -

5 ISTHIST+!I .
IF(IST-NSENS)31431932

DIMENS
DIMENS

29880105
29880107
29880108

29880113
29880115
29880117

29880123

29880201

29880212

29880203
29880205

29880209
29880211

29880213
29880214

29880215
29880217
32

31

101

4 |

30

-52-

GO TO NEXT CASE

I CONTR#D

PLTINC#TMAX

TMAX#De 0

NI#l

Go To 30

[IZH#IS(IST)Y

COLe I11Z OF HP MATRIX MULT o BY z
WRITE(6s101) IS(IST) »JS(IST)
FORMAT ( | 8HOSENSITIVITY TO As1351Hss1351H))
TIME#TZERO

NDT#I

“DO 41 I#1 NE

X(I)#0e0
Z(1)#0e0
JUFLAG#D

"DURING EACH SENSITIVITY RUN -

Z(IIZ)#XT(IST NDT)
NDT#NDT+ |

RE TURN

END

29880219
29880221

29880301
29880303

29880305

29880309

29880315 °

29880317
" $IBFTC SUBV DECK

OOO OOO ON

2
30

SUBRCUT INE VARCO(XTRsTX)

FOR USE WITH DISTRB AND MATEXP FCR
VARIABLE Z-Se GIVES 1-ST ORDER EXTRAP.

FOR AVGe X AND TIMEs PLUS RESTART
ON |-ST INTERVAL, DISTRB FORM #

CALCe MATRIX COEFFe-S»
CALL VARCO(XTRsTX)

ETC.

IF NI#O

CALCe Z-S USING XTR(I)=S AND TX (TIME).

DIMENSION A(60560)5C(60560)sHP (60960) sQPT(60560)
IX(60)sY(60)s2(60)sXICI60)TQP (60)

COMMON CsHPsA3sQPT 4X 9ZsYs ITMAX KKsLL yMM,
I JIFLAGsXICoNI 9 TIME s TMAX 3 TZEROSNEsTQP 3 Ts
21 1ZsICONTR4PLTINCIMATYES» ICSS»JFLAGHPLT

DIMENSION XTR(60)sXL (60)

IF(NI)1sls2

FIRST ENTRY

NV # |

TXH#TZERO+0 e5*T

DO 10 I#I1 sNE
XTROI)H#XIC(IY

GO To 30

IF(NV)3s344

SECOND ENTRY

NV#0

TIME#TZERO

PLT#De0D

DO I I#1 sNE
XLII)#XIC(])
XTR(I)#0. S5#¥ (XLOI)+X(I))
X{I)#XICI(I)

GO To 30

ENTRIES AFTER SECOND
TX#TIME+D«5%T

DO 12 I#I1sNE
XTRIIN#X(I)+0e5%*(X{1)=XL(I))
XLOIY#X (I)

RETURN

END

2880101
29880103
29880105
29880107
29880109
29880111
29880113
29880115
29880117
DIMENS .
DIMENS

29884118

29880120
29880121
29880122
29880124
29880202
29880204
29880206
29880208
29880210
29880212
2988021 4

29880216
29880218
29880220
29880222
29880224
2988030

29880303
29880305
29880307
29880309
29880311

29880313
"5h

$IBFTC FGEN CECK

C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C

2

100

7

101

86

200

3
C

4

5
C
C

18
10
13

SUBROUTINE DFG(XD,2ZD)

EQUIVALENT TO 8 DFG-S WITH UP TO 32
POINTS EACHe CALLED BY DISTRB.

INPUTS ARE
NDFGS NO. OF DFG-S USED
NPTS NOe. OF POINTS IN EACH DFG
XP INDEPENDENT VARIABLE DFG PCINTS
ZP DEPENDENT VARIABLE DFG POINTS

XD IS THE INPUT VARIABLE AND ZD THE QUTPUT

DIMENSION A(60+60)sC{60+60)sHP (6060) sQPT (60960)
FXTU60) oY (60)92160)sXICL60)sTQP (6D)

COMMON CsHP sA9sQPTsXsZsYs ITMAX9KKsLL s MMs

J JIJFLAGsXICHyNI 9 TIME 9 TMAXsTZERO SNE sTQP oT
211 Zs ICONTRHIPLTINCOMATYESsICSSsJFLAGSPLT

DIMENSICN XP(32+8)9ZP(32+8)9sSL (3298) sNPTSI(8)
IJP(8)52D(8)sXD(8)

IFINI) i921
FIRST CALL COMP.

READ (5,100)
FORMAT(1298Xs813)
DO 86 I1#14NDFGS
NP#NPTS (I)

READ (5.101)
FORMAT(8E (D3)
WRITE (65200) Ios (XP(JsI)sZP (Jel) sJ#I4NP)
OFORMAT (4HQODFGs 13, | 7H XP AND ZP INPUTS/

IF CIHO 94 (2E12e494X)))

DO 3 I#!sNDFGS

MENPTS(I1) |

DO 3 J#I eM

SLUJesIVH(ZP{JI+ 1 91) =ZP (Js ))/IXPLJ+1s1)-XP(JsI1))

NDFGSsNPTS

(XP(JeI)eZP (Jel) eJ#I| NP)

DO 5 I#1! sNDFGS

DO 4&4 J#2s32
IF(XD(IN=XP(Js1))5+544
CONTINUE

JP(I)#J

CALCS+ MADE EACH TIME

DO & I#! sNDFGS

JEJIP(T)
IF(XD(I)=XP(JsI))I0sllsl2
IF(XD(I)=XP(J=191))13s14s15
J#JI-1 :
IF(J=1)16s16s10

J#2

GO To 19

ZDUIIHZP(J=1s1}

Go To 6

NE NES

IF(NPTS(I)=J) 17518518

29880105 .

129880106
29880107
29880108
29880109
29880112
298801 [3
29880110
298801 14
29880115
29880116
DIMENS
DIMENS
25880117
25880118
29880119
29880121
29880122
29880123

29880124 -

29880125
29880201

29880202

29880204
29880205

29880207
29880208
29880209
29880210
2988021 i
29880212
29880213

29880214 -

29880215
29880216

29880218
29880219
29880220
-55-

JENPTS(I)

GO TO 19
ZD(IVH#ZP (Js 1)
GO TC 6

WRITE (69102) 1

FORMAT (4HODFGs 13,4 16H RANGE EXCEEDED.)

ZDCIVHZP(J=1 9 I)4SLIJ=1 oT) *¥(XD(I)=XP(J=151)).
JP(I) STORES VALUE OF XD LOCATION

TO USE AS FIRST TRY NEXT TIME.
JP #

RE TURN
END

29880222
29880223

29880224
29880225

29880301
29880302
29880303
29880304
$IBFTC TRLAG

AOC OOO OOO NOOO OOD

Nn NOAN

[@]

NO

OOO Cy

23

24

22.

20

®¥%¥s%% NOTE -—

33
31

26

-56-

DECK
SUBROUTINE TRLG(XTsWsZT)
VARIABLE TRANSPORT LAG GENERATOR - FORTRAN IV

USES UP TO 300 POINT APPROXIMATION FOR
UP TO 6 VARIABLES. USES INVENTORY CALC.

INPUTS FOR EACH LAG (TOTAL # NLAGS)

INPUT FUNCTION XT(1I)

MASS FLOWRATE W(I)

INITIAL VALUE OF LAG TIME TICI) .
MINIMUM EXPECTED VALUE OF MASS FLOW WMIN(I)

2e
3
4a

OUTPUTS ARE LAGGED FUNCTIONS ZT(I)

DIMENSION A(60+60)sC(60560)sHP (60560) sQPT (60560)
IX(60)sY(60)sZ2(60)sXIC(6D) TAP (60)

COMMON CsHP sAsQPTsX9ZsYs ITMAX KKsLL sMM,

| JIFLAGsXICoNI 9s TIME s TMAXSTZEROSNESTQP Ty

211ZsICONTRsPLTINCsMATYES,s1CSSsJFLAGSPLT

DIMENSION XT (6) sW(6)sTI(6)sWMIN(6)sZT (6)sXS (30056) 5
IPS(3006) sKT{6) sJT(6)sXIMP(6) 9s IMP (6) sNIMP (6)

NI # |-ST CALL FLAG {(# 0 ON
T # COMPUTATION TIME INTERVAL

I-ST CALL)

IF(NI)20s21,20

FIRST CALL COMP.

READ (5,100) NLAGS,sTI,WMIN
FORMAT (I2/(6E1043))
WRITE(6s101) TIsWMIN
FORMAT (26HOTRLG INPUTS — TI AND WMIN/(I1HOs6E1845))
DO 22 I#IsNLAGS

XJIMP (I) #10

XSU1sl)#XT(I)
PS(IsI)AW(II®TI(I)
XNSP#PS (11) / (WMIN(I)®T)
DO 23 M#I,10 |

PI#XJMP (1) %#XNSP
IF(300e0-P 1123424424

XJIMP (I) #XIMP(1)+1.0

JMPUIVAHIFIX(XIMP (1)

CKT(I)#2

JT (1) #]
NJMP (1) #1
NV #1

CALCS.

MADE EACH TIME
NVHNV + |

IF A RESTART FEATURE IS USED (WHERE THE INITIAL TIME
STEP CALCULATION IS REPEATED),
OMIT THE TRLG CALC. THIS
REMOVING STATEMENT 33.
IF(NV)31932,3]|

DO 17 I#!sNLAGS

LF (NJMP (1) =JMP11))26527,27
NIMP (1) #NIMP (1) + |

|-ST CALL OMISSION MAY BE DELETED BY

THE FLAG NV AND STATEMENT 33 WILL

29880105
29880106

29880108
29880109
298801 10
2988011 |
29880112

29880114

DIMENS
DIMENS

DIMENS
DIMENS

29880121 ~
29880123

DIMENS
DIMENS
29880202
29880203
29880204
29880206
DIMENS
29880209

29880212
29880213
29880214

29880216.

29880218
29880219
27

@® 0

-57=-

Go To 17

NJIMP (1) #1

KHKT (1)

JHIT(I)

XS(KsI)#XT(I)
PS(KsI)#XIMP (I) *W (1) *T
J#NOe OF ELEMENT AT EXIT. K#NO. AT ENTRANCE
IF(PS(Jsl)=PS(KsI))1s293
ZTOLYAXS (Js)
IF(J-300)697s7

JT) #]

GO TO 30

JTL) #J+]

Go To 30

COLLTH#XS(Js 1)
COLLP#PS(JysI1)
DO I15M#1+300
IF(J-300)8+955

J#0O

JH#EI+
PQ#COLLP+PS(Js1)

IF(PQ-PS{KsIN) 11912513
CCLLT#(COLLT*COLLP+XS{J,I)%PS(JsI))/PQ

COLLPHCOLLP+PS(Js1)
ZT(1)#(COLLT*#COLLP+XS(Js1)%¥PS(Js1))/PQ

IF(J=-300) 1416416
JT) #1

Go To 30
JTIY#J+I

GO To 30

PS(JsI)#PQ-PS(Ks1)
ZT(I)H#(COLLT*COLLP+XS(Js1)*¥PS(JsI))/(COLLP+PS (JI)
JTL #J

GO To 30

ZTLIY#XS UNI)
PS(Js IV #PS(JsI)-PS(K, 1)

IF(K~300)44+595
KT(1) #1

GO TO 17

KT (I) #K+1
CONTINUE

RE TURN
END

29880220
2988022 |
29880222
29880223
29880224

29880301
2988u302
29880303
DIMENS

25880205
29880306
25880307
29880308
29880309
298840310
2588031 i
DIMENS

DIMENS

25880316

29880319
29880320

DIMENS

29880401
29880402
29880403

29880404
29880405

29880407
29880408
29880409
29880410

29880412
26880413

DIMENS

29880416
29880417
25880418
29880419
 

 

 

 

 

 

i

4
1-30.
31.
32-61.
62.
63.
6h.
65.
66.
67.
68.
69.
70.
Tl.
72.
73.
Th.

75.

76.

Tle
78.

79.

81.
82.
83.
- 8h.
85.
86.
87.

88.

89.
90.

92.
93.
gl.
95.
96.

QUUEHEZQUUAQATHINEQWORUHArPQEHGE ANGE TOG QE nH

rh<grguwbibhoong<iImogEzzgngdaoaqEdepDmIog<sgi®

59

ORNL-TM-1933

INTERNAL DISTRIBUTION

. Adams

Anthony (K-25)

. Ball:
. Blalock

Borkowski
Bullock
Burke
Clark

. Dandl

Danforth
Davidson
Ditto

. Duggins

Engel
Epler

. Farris

Fowler (Y-12)
Fowler

Fry

Hagen
Harrill

. Hyland.
. Jamieson

Jordan

. Kaye

Kedl

. Kress
. Kryter
. Lawson 125-

Lucius
Mankin, Jr. (K-25)128-

. Martin
. McClain (K-25)
. McLain 135-

Metz
Miskell (Y-12)

. Moore
. Mossman

97.

98.

99.
100.
101.
102.
103.
10k,
105.
106.

. 107.

108.
109.
110.
111.
112.
113.
11k.
115.
116.

117.

118.
119.
120.
121.
122.
123.
12k,
126.
127.
132.
133.
134.
149.

150.

GHEE GOHUEU NEO EQUB UE UE O GE QQ

. Nestor

Nowlin

. O'Brien

Olsen

. Partain

. Patten

. Peele

. Perry

Pitkanen

Prince

. Roux

. Sadowski

Sartory

. Smith

L. Smith

Squires

Stone

. Tallackson

. Tobias

. Trinko
Tucker

. Walker

Watson

. Whatley

. Whitt

Wichner

. Wilson

M. M. Yarosh

Central Research Library

Document Reference:Section

Laboratory Records Department

Laboratory Records, ORNL R.C.

ORNL Patent Office

Division of Technical Infor-
mation Ext.

Research and Development
Division ORO

= Rog eEEDE aor noms

SdEEHLRRDOQTH IN
151.
152.
153.

154.
155.
156.
157.
158.
159.
160.
161.
162.
163.
164,
165.
166.
167.
168.
169.
170.
171.
172.

60

ORNL-TM-1933
EXTERNAL DISTRIBUTION

S. G. Bloom, Battelle Memorial Institute, Columbus, Ohio

Neal Carter, Battelle Northwest Labs., Richland, Washington

E. H. Cooke-Yarborough, Electronics Division, AERE,
Harwell, England

S. J. Gage, University of Texas

R. P. Gardner, North Carolina State University
B. E. Gilliland, Clemson University

S. H. Hanauer, University of Tennessee

T. H. M. Hung, Deere & Company, Moline, Illinois
J. M. Jansen, Jr., University of Illinois

T. W. Kerlin, University of Tennessee

‘L. B. Koppel, Purdue University

J. B. H. Kuper, Brookhaven National Laboratory
Rufus Oldenburger, Purdue University

H. M. Paynter, Massachusetts Institute of Technology
J. W. Prados, University of Tennessee
J. C., Robinson, University of Tennessee

R. F. Saxe, North Carolina State University

E. Siddall, AECL, Chalk River, Ontario
S. E. Stephenson, University of Arkansas
Otis Updike, University of Virginia

T. J. Williams, Purdue University

W. C. Wright, University of Tennessee

 

oy
